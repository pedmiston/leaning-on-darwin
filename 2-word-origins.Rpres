The origin of onomatopoeia
==========================
css: theme.css

Pierce Edmiston  
with Marcus Perlman and Gary Lupyan.

```{r, config, echo = FALSE, message = FALSE}
library(knitr)
opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  fig.width = 9,
  fig.align = "center",
  cache = FALSE
)

read_chunk("2-word-origins/setup.R")
read_chunk("2-word-origins/data.R")
read_chunk("2-word-origins/models.R")
read_chunk("2-word-origins/plots.R")
```

```{r, setup}
```

```{r, data}
```

```{r, models, cache = TRUE}
```

Bouba/kiki effect
=================
<p><a href="https://commons.wikimedia.org/wiki/File:Booba-Kiki.svg#/media/File:Booba-Kiki.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/e/e7/Booba-Kiki.svg" alt="Booba-Kiki.svg" height="112" width="220"></a>

- Some words might begin with meanings everyone agrees on.
- Illustrates the general phenomenon of _iconicity_.
- Criticized for being a handpicked example.
- What's the generative process for words like bouba and kiki?

<aside class="notes">
</aside>

Vocal imitation
===============
type: center
<iframe style="display: block; margin: auto;" width="420" height="315" src="https://www.youtube.com/embed/PaMNQ9ovCS8?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>

Can words emerge from imitations?
=================================
```{r, engine = "dot", fig.align = "left"}
digraph {
  node[fontname="helvetica"];
  rankdir=LR;

  imitation -> 1 -> 2 -> 3 -> 4 -> word;
  1[label=""];
  2[label=""];
  3[label=""];
  4[label="&#8230;"];
}
```

- _quack, sizzle, ooze, hiss, boom_
- But can we watch it happen?

<aside class="notes">
Given that people are good at imitations, and that imitations are an effective
way of conveying meaning when you don't have a word for something, we wanted
to find out if we can get words to emerge from imitations.

Can you start with an imitation and gradually form something that is more
wordlike simply by having people repeat the imitation over and over?

We have some suggestive examples of words with origins in imitations in English,
like onomatopoeia, words like quack, sizzle, ooze, hiss, boom.

But can we watch it happen in real time, and gradually, as a function of iteration?
</aside>

<!-- Telephone app -->

===

<img src="img/grunt.png" style="display: block; margin: auto;"></img>

<div style="text-align: center;">
  <div style="display: inline-block;">
    <audio src="http://sapir.psych.wisc.edu/evolang/riri.wav" controls></audio><audio src="http://sapir.psych.wisc.edu/evolang/riri-1.wav" controls></audio><br/>
    <audio src="http://sapir.psych.wisc.edu/evolang/splish.wav" controls></audio><audio src="http://sapir.psych.wisc.edu/evolang/splish-1.wav" controls></audio><br/>
  </div>
</div>

<aside class="notes">
To do this, I ran a version of the children's game of telephone online.
Here's what the game looked like.

The experiment was very simple: participants clicked on the top icon
to hear a message, and then they clicked on the bottom icon to make
their recording. They were instructed to repeat whatever they heard
as accurately as possible.

We didn't want to use animal sounds or anything that had a
lexical form, so instead we used sound effects, like the tearing of
paper, the clinking of glass bottles together, water sounds.

Here are two examples from an early version of the experiment.
</aside>

Design
======
```{r, engine = "dot"}
digraph {
  node[fontname="helvetica", fontsize=30];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  glass1 -> subj1;
  tear2 -> subj2;
  water3 -> subj3;
  zipper4 -> subj4;

  subj1[label="S1", style="filled", fillcolor="#66C2A5"];
  subj2[label="S1", style="filled", fillcolor="#66C2A5"];
  subj3[label="S1", style="filled", fillcolor="#66C2A5"];
  subj4[label="S1", style="filled", fillcolor="#66C2A5"];
}
```

<small>
- 4 categories of sounds, 4 seeds within each category.
- Seeds were normed to have equal variance within each category.
- Each participant made 4 imitations (from a seed in each category).
- 4 branches from each of the 16 seeds.
- Branches were ~8 generations long.
</small>

<aside class="notes">
I'm going to play you some more examples, but before I do, I want to
acquaint you with the design of the experiment, which looked like this.

We picked four categories
of sounds: glass sounds, tearing sounds, water sounds, and zipper sounds.

Within each of those categories, we had four distinct seeds, so we had
16 seeds total, but any given participant only made four responses: one
in each of the four categories. So the green circles here represent the first
subject in the experiment.
</aside>

<!-- Check out telephone app -->

Measuring imitation fidelity
============================
type: center

```{r, engine = "dot"}
digraph G {
  graph[fontname="helvetica"; fontsize=20];
  node[fontname="helvetica"];

  subgraph cluster0{
    label = "Telephone game"
    d -> d1 -> d2 -> d3 -> d4;
    c -> c1 -> c2 -> c3 -> c4;
    b -> b1 -> b2 -> b3 -> b4;
    a -> a1 -> a2 -> a3 -> a4;

    a[style="filled", fillcolor="#66c2a5"];
    b[style="filled", fillcolor="#66c2a5"];
    c[style="filled", fillcolor="#66c2a5"];
    d[style="filled", fillcolor="#66c2a5"];

    a1[label=""];
    a2[label=""];
    a3[label=""];

    b1[label=""];
    b2[label=""];
    b3[label=""];

    c1[label=""];
    c2[label=""];
    c3[label="", style="filled", fillcolor="#fc8d62"];

    d1[label=""];
    d2[label=""];
    d3[label=""];

    a4[style=invis];
    b4[style=invis];
    c4[style=invis];
    d4[style=invis];
  }

  gutter[style=invis];

  subgraph cluster1{
    label = "Guess the seed"
    choice_d[label="d"];
    choice_c[label="c"];
    choice_b[label="b"];
    choice_a[label="a"];

    {choice_a, choice_b, choice_c, choice_d} -> question[dir=back];

    choice_a[style="filled", fillcolor="#66c2a5"];
    choice_b[style="filled", fillcolor="#66c2a5"];
    choice_c[style="filled", fillcolor="#66c2a5"];
    choice_d[style="filled", fillcolor="#66c2a5"];

    question[label="?", style="filled", fillcolor="#fc8d62"];
  }

}
```

<aside class="notes">
We ran the telephone game and collected a bunch of these imitations
and then we needed some way to measure how the imitations are changing
over generations.

To do that we had a different group of subjects 
listen to each of the imitations, and see if they can guess which seed
lead to that imitation.

I'll call this the "Guess the seed" game, and in all cases people
were given four choices, and they had to pick the one that most
resembled the imitation that they were listening to.

In this case, the highlighted imitation
came from the "c" seed, so the correct answer to the Guess the
seed question is "c".

If people are above chance at guessing the seed, we can say that the
imitation has some fidelity to the original source. However, if you
played the game of telephone as a kid, you know that the message
that comes out the end often barely resembles what you started with.
If people are guessing at chance, we would say that the imitation lost
fidelity.

So that's what I mean by imitation fidelity: the ability to relate
a particular imitation back to the original source.
</aside>

===

<img src="img/survey.png" style="display: block; margin: auto;"></img>

<aside class="notes">
Here is what the Guess the seed game looked like. They listened to an imitation
and then picked one of four options.

And of course they are totally blind to the design of the experiment,
what generation the imitations came from, and they don't get any
feedback on their performance.
</aside>

Are imitations becoming more wordlike?
======================================
type: center
```{r, engine = "dot"}
digraph {
  node[fontname="helvetica"];
  rankdir=LR;
  
  specific -> categorical;

  imitative -> 1 -> 2 -> 3 -> 4 -> wordlike;
  1[label=""];
  2[label=""];
  3[label=""];
  4[label="&#8230;"];
  
  {rank=same; specific, imitative};
  {rank=same; categorical, wordlike};
  
  specific[shape="none"];
  categorical[shape="none"];
}
```

<aside class="notes">
So how do we know if the imitations are becoming more wordlike?

One property of words that I think about a lot is that words are categorical, 
whereas imitations are more specific. If you are imitating a dog, you are 
imitating a particular dog. An imitation of a yorkie sounds different than an
imitation of a German shepherd. But the word dog is more general, it leaves the
type of dog unspecified.

This has a specific prediction for what should be happening with the
imitations. If they are becoming more wordlike, the imitations should
lose  individuating information more rapidly than category
information.

Remember that in the design of the experiment we have four categories
of sounds, and four seeds within each category. Category information
is the ability to distinguish an imitation from any of the seeds in
a particular category from the other categories.

Individuating information is the ability to identify the exact seed
that lead to the imitation within a particular category.

Now, I designed the experiment in this way so that I could take each
imitation and have it rated in different version of the guess the seed
game. And we can use these ratings to address the question of whether
the words are becoming more wordlike.

So now I'll show you how I structured the Guess the seed games.
</aside>

===
```{r, engine = "dot"}
digraph {
  labelloc="t";
  label="Category match (true seed)";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  glass1[style="filled", fillcolor="#66C2A5"];
  tear2[style="filled", fillcolor="#66C2A5"];
  water3[style="filled", fillcolor="#66C2A5"];
  zipper4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

```{r, engine = "dot"}
digraph {
  labelloc="t";
  label="Category match";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  glass1[style="filled", fillcolor="#66C2A5"];
  tear3[style="filled", fillcolor="#66C2A5"];
  water3[style="filled", fillcolor="#66C2A5"];
  zipper4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

```{r, engine = "dot"}
digraph {
  labelloc="t";
  label="Specific match";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  tear1[style="filled", fillcolor="#66C2A5"];
  tear2[style="filled", fillcolor="#66C2A5"];
  tear3[style="filled", fillcolor="#66C2A5"];
  tear4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

<aside class="notes">
So we took each imitation and had it rated in three different Guess the seed conditions, represented here as three different rows.

You should recognize the design of the telephone game with the four
categories and the four seeds within each category. And remember for the
Guess the seed game people are given a single imitation -- here the
imitation is orange, and they have to pick which seed the imitation
game from.

So these three Guess the seed games differ only in the choices that
the participant is given.

Let's start with the easiest condition at the top.
In this condition the correct answer is the actual seed that
lead to the imitation, and the distractor choices are from 
different categories. I call this
the "Category match (true seed)" condition.

The second condition, the "Category match" condition, is a bit
harder. You're still given seeds from four different categories,
but the correct answer is not the "true seed" but a different seed from
the same category.

Performance in this "Category match" condition is really important.
If an imitation leads to above chance performance in this condition,
it means it's a good cue for the category of sounds as a whole.

The last condition is the hardest. In the "Specific match" condition
you have to match the true seed, but the distractors are from the
same category. Now, an imitation that is a good cue for the category
as a whole will not perform well in this condition, because if it
is a good cue for all of the seeds, then you probably can't tell
which exact seed lead to that imitation.

Ok, so again: we collected all of those imitation in the telephone game
and then for each imitation, we had it rated in each of these three
conditions. And now we can see how good the imitations were.
</aside>

<!-- First generation -->

===
```{r, first-gen}
```

<aside class="notes">
So here we have Guess the seed performance for all imitation in
each of the three conditions.

The first thing to notice is that performance in all three conditions
is above chance, which requires both good imitations and good guesses.

The next thing to note is that the order is what we would expect.
The category match where you are given the true seed is the easiest,
and the specific match is the hardest.

Now this is the first generation, and I want you to think about what is going to happen when we look
across generations.

Again, the prediction is that the imitations will lose the individuating
information more rapidly than they lose the category information. This
plays itself out in two ways.

First, focus on the two category match conditions. We can call the difference
between them the "true seed advantage": it's the benefit you get as a
guesser when one of the category options is the actual seed that generated
the imitation. This true seed advantage depends on individuating information;
it depends on the imitation in some way resembling a particular seed more
than the other members of the same category. So if the imitations lose
the individuating information,
we would expect this true seed advantage to decrease.

Ok, now focus on the difference between the category match condition
and the specific match condition. The specific match condition obviously
depends on individuating information, and the category match condition
doesn't, because the correct answer is not the specific seed that lead
to the imitation. So here we expect the difference between the two conditions
to get bigger: performance in the specific match condition should
drop more rapidly than performance in the category match condition.
</aside>

<!-- Match to seed -->

===
```{r, match-to-seed}
```

===
```{r, snapshots, fig.width = 14}
```

Are imitations becoming more wordlike?
======================================
type: center
```{r, engine = "dot"}
digraph {
  node[fontname="helvetica"];
  rankdir=LR;
  
  specific -> categorical;

  imitative -> 1 -> 2 -> 3 -> 4 -> wordlike;
  1[label=""];
  2[label=""];
  3[label=""];
  4[label="&#8230;"];
  
  {rank=same; specific, imitative};
  {rank=same; categorical, wordlike};
  
  specific[shape="none"];
  categorical[shape="none"];
}
```

<aside class="notes">
Ok, so this is really interesting. It suggests that what is happening
as these nonverbal imitations are iterated is not a uniform degradation
of the original signal. The imitations are losing the specific,
individuating information more rapidly than the category information,
which supports the idea that the imitations are indeed becoming more
wordlike.

But are they becoming actual words? Can you write them down?
</aside>

===

<div style="text-align: center;">
  <div style="display: inline-block;">
    <div>
      dahduhda<br/>
      <audio src="http://sapir.psych.wisc.edu/evolang/glass-seed.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/glass-gen1.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/glass-gen7.wav" controls></audio>
      <br/>
    </div>
    <div>
      cheea<br/>
      <audio src="http://sapir.psych.wisc.edu/evolang/tear-seed.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/tear-gen1.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/tear-gen7.wav" controls></audio>
      <br/>
    </div>
    <div>
      glongglong<br/>
      <audio src="http://sapir.psych.wisc.edu/evolang/water-seed.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/water-gen1.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/water-gen5.wav" controls></audio>
      <br/>
    </div>
    <div>
      izit<br/>
      <audio src="http://sapir.psych.wisc.edu/evolang/zipper-seed.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/zipper-gen1.wav" controls></audio>
      <audio src="http://sapir.psych.wisc.edu/evolang/zipper-gen6.wav" controls></audio>
      <br/>
    </div>
  </div>
</div>

===
```{r, transcription-agreement}
```

Transcriptions
==============
type: center
```{r, engine = "dot"}
digraph G {
  graph[fontname="helvetica"; fontsize=20];
  node[fontname="helvetica"];

  subgraph cluster0{
    label = "Telephone game"
    d -> d1 -> d2 -> d3 -> d4;
    c -> c1 -> c2 -> c3 -> c4;
    b -> b1 -> b2 -> b3 -> b4;
    a -> a1 -> a2 -> a3 -> a4;

    a[style="filled", fillcolor="#66c2a5"];
    b[style="filled", fillcolor="#66c2a5"];
    c[style="filled", fillcolor="#66c2a5"];
    d[style="filled", fillcolor="#66c2a5"];

    a1[label=""];
    a2[label=""];
    a3[label=""];

    b1[label=""];
    b2[label=""];
    b3[label=""];

    c1[label=""];
    c2[label=""];
    c3[label=""];

    d1[label=""];
    d2[label=""];
    d3[label=""];

    a4[label="word"];
    b4[label="word"];
    c4[label="word", style="filled", fillcolor="#fc8d62"];
    d4[label="word"];
  }

  gutter[style=invis];

  subgraph cluster1{
    label = "Guess the seed"
    choice_d[label="d"];
    choice_c[label="c"];
    choice_b[label="b"];
    choice_a[label="a"];

    {choice_a, choice_b, choice_c, choice_d} -> question[dir=back];

    choice_a[style="filled", fillcolor="#66c2a5"];
    choice_b[style="filled", fillcolor="#66c2a5"];
    choice_c[style="filled", fillcolor="#66c2a5"];
    choice_d[style="filled", fillcolor="#66c2a5"];

    question[label="word", style="filled", fillcolor="#fc8d62"];
  }

}
```

===
```{r}
ggplot(matches, aes(x = question_f, y = is_correct)) +
  geom_bar(aes(fill = question_f), stat = "identity", data = matches_preds,
           width = 0.96) +
  geom_linerange(aes(ymin = is_correct - se, ymax = is_correct + se), data = matches_preds) +
  chance_line +
  coord_cartesian(ylim = c(0, 1.0)) +
  scale_x_discrete("", labels = c("Category match (true seed)", "Category match")) +
  scale_y_accuracy +
  scale_fill_categories +
  base_theme +
  theme(legend.position = "none") +
  ggtitle("Guess the seed accuracy with transcriptions")

```

Conclusions
===========
- We can measure non-random change in the telephone game!
- Imitations lose individuating information more rapidly than category information.
- Iterating imitations makes them more wordlike.

> Invented words retain the iconicity of the imitations.

Early stages
============
- What's the acoustic difference between subsequent imitations?
- How can we make the interactions more communicative?
- What other sorts of iterated signals exhibit systematic change?
